# Developer Docs
Here, we document information useful when developing the Tapis Authenticator.

At a high level, this project is based on the AuthLib project - https://github.com/lepture/authlib - a Python library
for building OAuth and OpenID Connect servers. Details regarding the Flask OAuth2 provider server implementation can
be found here: https://docs.authlib.org/en/latest/flask/2/index.html


## Configuration

Authenticator makes use of different configuration data from different sources. The following describes
the various sources of configuration data and how to manage it.

### Service Config (`config.json`)
Like all Tapis services, Authenticator makes use of service configuration provided to it at run time. It uses the
standard approach used by all Tapis Python services for service configuration -- a JSON file loaded into the 
container that adheres to the corresponding JSONSchema document. Like all Tapis Python services, the schema file
lives in `configschema.json` in the project root and extends the tapipy-tapisservice base configschema.json. The
`config-local.json` file, also in the project root, provides example values for running Authenticator locally. 
When deployed into a Tapis environment, the contents of this file are generated by the deployment mechanism (e.g., Tapis Deployer).

Note that, generally speaking, the service config provides configuration values that are globally applicable to all tenants served by the deployer -- configurations such as the authenticator service account and password, the 
Postgres host and username it should use, and default values to apply to all tenants. Making changes to the 
service config requires the Authenticator container to be restarted.


## LDAP Config
Authenticator makes requests to LDAP servers as part of authenticating users. The configuration of these LDAPs
includes information regarding the server itself (host and port) as well as information about which users to 
allow to bind with. The LDAP config is stored with the Tenants API -- this decision was made to allow the 
config to be available to other services. The LDAP object can be retrieved from the Tenants API using the
LDAP ID.

The ldap object determines who can authenticate in the tenant. The object definition includes both the server 
and credentials as well as the user dn. Tenants that have different LDAP OUs will need to have their
own LDAP object defined even if it is the same LDAP server. On the other hand, tenants that use the "dev" ldap
should be able to use the same ldap config object because the host is the same (authenticator-ldap) regardless of
what k8s cluster the ldap pod is running it; the authenticator pod running in the same cluster will use the Kube 
DNS to resolve "authenticator-ldap" to the ldap pod in the same k8s cluster.

Note that, by default, the username attribute used when querying the ldap DB is baked
into the user_dn attribute using the `<username_attr>=${username}` syntax. The `${username}` token will be replaced by Authenticator at run time. Authenticator uses a default of `cn` for the username attribute if the `${username}`token is not present in the user_dn. In summary:

  * if `user_dn` contains the string `${username}`, Authenticator will replace this with the actual username.
  * if `user_dn` does not contain `${username}`, Authenticator will use `cn=<username>`, prepended to the user_dn.

Also note that the bind credential (i.e., password) that Authenciator uses to bind to the LDAP is a secret stored
in the Tapis SK. When creating a new LDAP object, a new credential will need to be stored with SK, unless an 
existing credential can be used (for example, the same credential can be used to bind to TACC LDAP). The new 
credential needs to be owned by Authenticator. Use the `store_ldap_bind_secret_in_sk()` function within the 
Authentictor (the __init__.py file) to save the credential.

It should be noted that the Authentication can be customized for a given tenant using a custom_ldap_config
object, defined within the authenticator database itself. These customization options include:

 * user_search_filter
 * user_search_prefix
 * user_search_supplemental_filter

If user_search_filter is used, it is used exclusively, while user_search_prefix and user_search_supplemental_filter 
can be used together.


## Tenant-Specific Configs
In addition to the service config and LDAP objects, Authenticator makes use of tenant-specific configs stored in
its database (see the `models.TenantConfig` class). It can be updated at run time and through a REST endpoint.

Each tenant gets a single config record on the table. The table includes configs are that simple types, such as 
the `allowable_grant_types` and the `default_access_token_ttl`, but it also includes complex configs which are 
themselves JSON objects governed by JSONSchema. 


### Custom IdP Config

The `custom_idp_configuration` is a JSON column on the `models.TenantConfig` table. It is used when a tenant wants to leverage an identity provider (IdP) that is not an LDAP/AD server. Currently, 
3rd-party OAuth/OIDC servers such as GitHub, Google and Globus are supported. 

The format of the `custom_idp_configuration` is governed by the `custom_idp_configschema.json`, 
a JSONSchema definition file located within the `resources` directory. This usually amounts to 
providing the client key and secret. For example, here is how you would configure the "github-demo"
tenant to use GitHub OAuth:

```
c = TenantConfig.query.filter_by(tenant_id='github-demo')[0]
d = {'github': { 'client_id': '35G7.....445H', 'client_secret': 'ef35.......c98fed'}}
s = json.dumps(d)
c.custom_idp_configuration = s
db.session.commit()

```
Note that the GitHub oauth clients are registered with the tapis-project GitHub organization. 
See here for managing them: https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app

The "cii" configuration type is a little different because it does not adhere to the OAuth spec.
Instead of a client ID and key, the `jwt_decode_key` is needed,as well as whether or not to check
the signature and the login URL. HEre is an example configuration that works for CII:

```
# cii in dev
c = TenantConfig.query.filter_by(tenant_id='cii')[0]
d = {'cii': {'login_url': 'https://dev.construction-institute.org/authentication/sso-login', 'jwt_decode_key': 'Dw.......8I', 'check_jwt_signature': True} } 
```




### MFA Config